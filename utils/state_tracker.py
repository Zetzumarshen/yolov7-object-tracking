import pandas as pd
from utils.count_utils import check_box_position, frame_to_timestamp, get_line_orientation

class BBoxState:
    def __init__(self, object_id, bbox_xyxy, class_label, class_confidence, orientation_label = None):
        self.object_id = object_id # object ID are generated by the tracker
        self.class_label = class_label
        self.class_confidence = class_confidence
        self.bbox_xyxy = bbox_xyxy 
        self.orientation_label = orientation_label
        self.in_out_counter = None

class StateTracker:
    def __init__(self, line_roi, fps, in_orientation=None):
        """
        Initialize the StateTracker object.

        Parameters:
        - line_roi (str): The region of interest of the line.
        - in_orientation (str): What counts as in orientation opposed to out orientation. 
          Can be "left", "right", "above", or "bottom". E.g. if an object start from "left" and goes to "right", 
          then increment in_counter. Also if given nothing: 
            If line_roi is "horizontal", in_orientation defaults to "right" 
            If line_roi is "vertical", in_orientation defaults to "bottom"

        Attributes:
        - state_history (list): A list of state history. Each state is a list of dictionary, where each dictionary represents
            an one frame passed and its bounding box objects in that frame.
        - fps (int): frame per second
        - line_roi (str): The region of interest of the line. xyxy point structure
        - in_orientation (str): The starting orientation of the line.
        """
        self.state_history = []
        self.fps = fps
        self.line_roi = line_roi # region of interest

        if get_line_orientation(line_roi) == "horizontal":
            if in_orientation == "left" or in_orientation == "right":
                self.in_orientation = "right" # defaults using right to left flow incounter
            else:
                self.in_orientation = in_orientation 
        else:  # "vertical"
            if in_orientation == "above" or in_orientation == "bottom":
                self.in_orientation = "bottom" # defaults using bottom to above flow incounter
            else:
                self.in_orientation = in_orientation 
 
    def detect_change_in_out_counter(self, fps):
        """
        This function takes a list of `statehistory` as input and detects the changes in the `in_out_counter` for each `object_id` 
        in each frame. It returns a list of dictionaries that contains information about the `object_id`, `frame_number`, 
        the change in the `in_out_counter` (i.e., 'in', 'out', 'return'), and the timestamp. 

        Returns:
            result (list): A list of dictionaries, where each dictionary contains the following key-value pairs:
                object_id (int): The id of the object
                frame_number (int): The number of the frame in which the change in `in_out_counter` was detected
                count (str): The change in `in_out_counter` ('in', 'out', 'return')
                timestamp (float): The timestamp of the event in seconds
            
        Example output:
        [
            {
                "object_id": 1,
                "frame_number": 0,
                "count" : "in",
                "timestamp": 0.0
            },
        ]
        """
        result = []
        for frame_number, frame in enumerate(self.statehistory):
            for obj in frame:
                obj_id = obj['object_id']
                count = obj['in_out_counter']
                if frame_number == 0:
                    if count == 1:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'in', 'timestamp': frame_to_timestamp(frame_number, self.fps)})
                    elif count == -1:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'out', 'timestamp': frame_to_timestamp(frame_number, self.fps)})
                else:
                    prev_frame = self.statehistory[frame_number - 1]
                    prev_obj = next((x for x in prev_frame if x['object_id'] == obj_id), None)
                    prev_count = prev_obj['in_out_counter'] if prev_obj else 0
                    if prev_count == 0 and count == 1:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'in', 'timestamp': frame_to_timestamp(frame_number, self.fps)})
                    elif prev_count == 1 and count == 0:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'return', 'timestamp': frame_to_timestamp(frame_number, self.fps)})
                    elif prev_count == 0 and count == -1:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'out', 'timestamp': frame_to_timestamp(frame_number, self.fps)})
                    elif prev_count == -1 and count == 0:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'return', 'timestamp': frame_to_timestamp(frame_number, self.fps)})


    def detect_change_in_out_counter(self):
        """
        This function takes a list of `statehistory` as input and detects the changes in the `in_out_counter` for each `object_id` 
        in each frame. It returns a list of dictionaries that contains information about the `object_id`, `frame_number`, and the 
        change in the `in_out_counter` (i.e., 'in', 'out', 'return'). 

        Returns:
            result (list): A list of dictionaries, where each dictionary contains the following key-value pairs:
                object_id (int): The id of the object
                frame_number (int): The number of the frame in which the change in `in_out_counter` was detected
                count (str): The change in `in_out_counter` ('in', 'out', 'return')
        
        Example output:
        [
            {
                "object_id": 1,
                "frame_number": 0,
                "count" : "in"
            },
        ]
        """
        result = []
        for frame_number, frame in enumerate(self.statehistory):
            for obj in frame:
                obj_id = obj['object_id']
                count = obj['in_out_counter']
                if frame_number == 0:
                    if count == 1:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'in'})
                    elif count == -1:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'out'})
                else:
                    prev_frame = self.statehistory[frame_number - 1]
                    prev_obj = next((x for x in prev_frame if x['object_id'] == obj_id), None)
                    prev_count = prev_obj['in_out_counter'] if prev_obj else 0
                    if prev_count == 0 and count == 1:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'in'})
                    elif prev_count == 1 and count == 0:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'return'})
                    elif prev_count == 0 and count == -1:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'out'})
                    elif prev_count == -1 and count == 0:
                        result.append({'object_id': obj_id, 'frame_number': frame_number, 'count': 'return'})

    def agg_labels_and_conf_by_obj_id(self):
        """
        Aggregate object labels and confidences by object ID.

        :Example output:
        [
            {
                "object_id": 1,
                "class_label": "cat",
                "class_confidence": 0.52
            },
        ]
        """
        # Flatten the list of dictionaries
        flat_list = [item for sublist in self.state_history for item in sublist]

        # Convert the list of dictionaries to a pandas DataFrame
        df = pd.DataFrame(flat_list)

        # Group the data by object_id and class_label and calculate the mean of class_confidence
        df = df.groupby(['object_id', 'class_label']).mean().reset_index()

        # Convert the DataFrame back to a list of dictionaries
        return df.to_dict('records')

    def add_bounding_box(self, object_id, bbox_xyxy, class_label, class_confidence):
        """
        Add an bounding box to the current frame in the state history, and compares it with region of interest
        
        Parameters:
        object_id (int): unique identifier for the object
        bbox_xyxy (tuple): bounding box coordinates in the format (xmin, ymin, xmax, ymax)
        class_label (str): class label for the object
        class_confidence (float): confidence score for the class label

        """
        prev_frame_bbox_states = self.get_previous_frame_objects() if self.state_history else []
        prev_frame_bbox_state = next((x for x in prev_frame_bbox_states if x.object_id == object_id), None)

        curr_frame_bbox_state = BBoxState(object_id, bbox_xyxy, class_label, class_confidence)
        curr_frame_bbox_state.orientation_label = check_box_position(curr_frame_bbox_state, self.line_roi)
        curr_frame_bbox_state.in_out_counter = self.update_in_out_counter(self, prev_frame_bbox_state, curr_frame_bbox_state)

        if self.state_history:
            self.state_history[-1].append(curr_frame_bbox_state)
        else:
            self.state_history = [[curr_frame_bbox_state]]
    
    def update_in_out_counter(self, prev_frame_object_state, current_frame_object_state):
        line_orientation = get_line_orientation(self.line_roi)
        in_orientation = self.in_orientation
        prev_in_out_counter = prev_frame_object_state.in_out_counter
        
        curr_label = current_frame_object_state.orientation_label
        if prev_frame_object_state == None:
            prev_label = None
        else:
            prev_label = prev_frame_object_state.orientation_label 

        if prev_label == None:
            return 1 if curr_label == "intersect" else 0
        
        in_out_delta = 0
        if line_orientation == "horizontal":
            if in_orientation == "bottom":
                in_out_delta = 1 if prev_label == "bottom" and curr_label == "intersect" else -1 if prev_label == "above" and curr_label == "intersect" else 0
            else: # from above
                in_out_delta = -1 if prev_label == "bottom" and curr_label == "intersect" else 1 if prev_label == "above" and curr_label == "intersect" else 0
        else: # vertical
            if in_orientation == "right":
                in_out_delta = 1 if prev_label == "right" and curr_label == "intersect" else -1 if prev_label == "left" and curr_label == "intersect" else 0
            else: # from left
                in_out_delta = -1 if prev_label == "right" and curr_label == "intersect" else 1 if prev_label == "left" and curr_label == "intersect" else 0
        
        return prev_in_out_counter + in_out_delta if prev_label == "intersect" and curr_label == "intersect" else in_out_delta


    def get_current_frame_number(self):
        return len(self.state_history) - 1

    def get_previous_frame_number(self):
        return len(self.state_history) - 2
            
    def get_current_frame_objects(self):
        return self.state_history[-1] if self.state_history else []
 
    def get_previous_frame_objects(self):
        return self.state_history[-2] if len(self.state_history) > 1 else []